# Written by Dr Daniel Buscombe, Marda Science LLC
# for "ML Mondays", a course supported by the USGS Community for Data Integration
# and the USGS Coastal Change Hazards Program
#
# MIT License
#
# Copyright (c) 2020, Marda Science LLC
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


from cairosvg import svg2png
import skimage
import PIL.Image
import io
import numpy as np

##========================================================
def hex_to_rgb(value):
    value = value.lstrip('#')
    lv = len(value)
    return tuple(int(value[i:i + lv // 3], 16) for i in range(0, lv, lv // 3))

##========================================================
def svg_code_to_array(svg_code):
    svg_code = ''.join(svg_code)
    groups = svg_code.split('<svg')[1:]
    w = int(groups[0].split("width=")[1].split("\n")[0].replace('"',''))
    h = int(groups[0].split("height=")[1].split("\n")[0].replace('"',''))
    arr = np.zeros((w,h,3), dtype=np.uint8)
    for g in groups:
        col = g.split("stroke=")[1].split("\n")[0].replace('"','')
        tmp = g.split("d=")[1].split("\n")[0].replace('"','').replace('M','').replace('L',',')
        X = np.round(np.array(tmp.split(',')[::2], np.float)).astype(np.int8)
        Y = np.round(np.array(tmp.split(',')[1::2], np.float)).astype(np.int8)
        del tmp
        pw = int(float(g.split("pen-width=")[1].split("\n")[0].replace('"',''))/2)
        rgb = hex_to_rgb(col)
        for y, x in zip(X,Y):
            arr[x-pw:x+pw,y-pw:y+pw,:] = rgb

    return arr

def shape_to_svg_code(shape,
    fig=None,
    width=None,
    height=None):
    """
    fig is the plotly.py figure which shape resides in (to get width and height)
    and shape is one of the shapes the figure contains.
    """

    if fig is not None:
        # get width and height
        wrange = next(fig.select_xaxes())["range"]
        hrange = next(fig.select_yaxes())["range"]
        width, height = [max(r) - min(r) for r in [wrange, hrange]]
    else:
        if width is None or height is None:
            raise ValueError("If fig is None, you must specify width and height")

    fmt_dict = dict(
        width=width,
        height=height,
        stroke_color=shape["line"]["color"],
        pen_width=shape["line"]["width"],
        path=shape["path"],
    )

    return """
<svg
    width="{width}"
    height="{height}"
    viewBox="0 0 {width} {height}"
>
<path
    stroke="{stroke_color}"
    pen-width="{pen_width}"
    d="{path}"
    fill-opacity="0"
/>
</svg>
""".format(
        **fmt_dict
    )


def shape_to_png(fig=None,
    shape=None,
    width=None,
    height=None,
    write_to=None):
    """
    Like svg2png, if write_to is None, returns a bytestring. If it is a path
    to a file it writes to this file and returns None.
    """

    svg_code = shape_to_svg_code(fig=fig, shape=shape, width=width, height=height)

    # f = open("svg-annotations.txt", "a")
    # f.write(svg_code)
    # f.close()

    r = svg2png(bytestring=svg_code, write_to=write_to)

    return r


def shapes_to_mask(shape_args, shape_layers):
    """
    Returns numpy array (type uint8) with number of rows equal to maximum height
    of all shapes's bounding boxes and number of columns equal to their number
    of rows.
    shape_args is a list of dictionaries whose keys are the parameters to the
    shape_to_png function.
    The mask is taken to be all the pixels that are non-zero in the resulting
    image from rendering the shape.
    shape_layers is either a number or an array
    if a number, all the layers have the same number in the mask
    if an array, must be the same length as shape_args and each entry is an
    integer in [0...255] specifying the layer number. Note that the convention
    is that 0 means no mask, so generally the layer numbers will be non-zero.
    """

    images = []
    for sa in shape_args:
        pngbytes = shape_to_png(**sa)
        images.append(PIL.Image.open(io.BytesIO(pngbytes)))

    mwidth, mheight = [max([im.size[i] for im in images]) for i in range(2)]
    mask = np.zeros((mheight, mwidth), dtype=np.uint8)

    if type(shape_layers) != type(list()):
        layer_numbers = [shape_layers for _ in shape_args]
    else:
        layer_numbers = shape_layers

    imarys = []
    for layer_num, im in zip(layer_numbers, images):
        # layer 0 is reserved for no mask
        imary = skimage.util.img_as_ubyte(np.array(im))
        imary = np.sum(imary, axis=2)
        imary.resize((mheight, mwidth))
        imarys.append(imary)
        mask[imary != 0] = layer_num

    return mask
